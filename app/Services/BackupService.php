<?php

namespace App\Services;

use App\Models\Backup;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Storage;
use Exception;
use Carbon\Carbon;

class BackupService
{
    protected $backupPath;
    protected $fileName;
    protected $fullPath;
    protected $excludedTables = [
    ];

    public function __construct()
    {
        $this->backupPath = 'backups/' . date('Y') . '/' . date('m') . '/' . date('d');
        $this->fileName = 'backup-' . Carbon::now()->format('Y-m-d-H-i-s') . '.sql';
        $this->fullPath = $this->backupPath . '/' . $this->fileName;
    }

    public function createBackup(): Backup
    {
        try {
            // Create backup record
            $backup = Backup::create([
                'name' => $this->fileName,
                'path' => $this->fullPath,
                'status' => 'processing',
            ]);

            // Generate the SQL backup content using chunked approach
            $this->generateChunkedSqlBackup();
            
            // Update backup record with success status and size
            $size = Storage::disk('public')->size($this->fullPath);
            
            $backup->update([
                'size' => $size,
                'status' => 'completed',
            ]);
            
            return $backup;
            
        } catch (Exception $e) {
            // Update backup record with error
            if (isset($backup)) {
                $backup->update([
                    'status' => 'failed',
                    'error' => $e->getMessage(),
                ]);
            }
            
            throw $e;
        }
    }
    
    protected function generateChunkedSqlBackup(): void
    {
        // Get database configuration
        $db = config('database.connections.mysql');
        $database = $db['database'];
        
        // Start with SQL header
        $sqlHeader = "-- MySQL dump generated by Laravel Backup System\n";
        $sqlHeader .= "-- Host: {$db['host']}\n";
        $sqlHeader .= "-- Database: $database\n";
        $sqlHeader .= "-- Generation Time: " . Carbon::now()->toDateTimeString() . "\n\n";
        $sqlHeader .= "SET SQL_MODE = \"NO_AUTO_VALUE_ON_ZERO\";\n";
        $sqlHeader .= "SET AUTOCOMMIT = 0;\n";
        $sqlHeader .= "START TRANSACTION;\n";
        $sqlHeader .= "SET time_zone = \"+00:00\";\n\n";
        
        // Write header to file
        Storage::disk('public')->put($this->fullPath, $sqlHeader);
        
        // Get all tables except excluded ones
        $tables = DB::select('SHOW TABLES');
        
        foreach ($tables as $table) {
            $tableName = $table->{'Tables_in_' . $database};
            
            // Skip excluded tables
            if (in_array($tableName, $this->excludedTables)) {
                continue;
            }
            
            $this->backupTable($tableName, $database);
        }
        
        // Add commit statement
        Storage::disk('public')->append($this->fullPath, "COMMIT;\n");
    }
    
    protected function backupTable(string $tableName, string $database): void
    {
        // Table structure
        $tableStructure = "--\n";
        $tableStructure .= "-- Table structure for table `$tableName`\n";
        $tableStructure .= "--\n\n";
        $tableStructure .= "DROP TABLE IF EXISTS `$tableName`;\n";
        
        $createTable = DB::select("SHOW CREATE TABLE `$tableName`");
        $tableStructure .= $createTable[0]->{'Create Table'} . ";\n\n";
        
        Storage::disk('public')->append($this->fullPath, $tableStructure);
        
        // Table data - use chunking for large tables
        $this->backupTableData($tableName);
    }
    
    protected function backupTableData(string $tableName): void
    {
        $dataHeader = "--\n";
        $dataHeader .= "-- Dumping data for table `$tableName`\n";
        $dataHeader .= "--\n\n";
        
        Storage::disk('public')->append($this->fullPath, $dataHeader);
        
        $chunkSize = 1000; // Adjust based on your memory limits
        $offset = 0;
        $hasData = false;
        
        do {
            // Get data in chunks
            $rows = DB::table($tableName)
                     ->skip($offset)
                     ->take($chunkSize)
                     ->get();
            
            if ($rows->count() > 0) {
                $hasData = true;
                
                if ($offset === 0) {
                    Storage::disk('public')->append($this->fullPath, "INSERT INTO `$tableName` VALUES ");
                }
                
                $insertValues = [];
                foreach ($rows as $row) {
                    $values = [];
                    foreach ((array) $row as $value) {
                        if ($value === null) {
                            $values[] = "NULL";
                        } else {
                            $values[] = "'" . addslashes($value) . "'";
                        }
                    }
                    $insertValues[] = "(" . implode(", ", $values) . ")";
                }
                
                // Append data with proper formatting
                $data = implode(",\n", $insertValues);
                if ($offset > 0) {
                    $data = ",\n" . $data;
                }
                
                Storage::disk('public')->append($this->fullPath, $data);
                
                // Free memory
                unset($rows, $insertValues);
                
                $offset += $chunkSize;
            } else {
                break;
            }
            
        } while (true);
        
        if ($hasData) {
            Storage::disk('public')->append($this->fullPath, ";\n\n");
        } else {
            Storage::disk('public')->append($this->fullPath, "-- No data in table `$tableName`\n\n");
        }
    }
    
    public function downloadBackup(Backup $backup)
    {
        if (!Storage::disk('public')->exists($backup->path)) {
            throw new Exception('Backup file not found.');
        }
        
        return Storage::disk('public')->download($backup->path, $backup->name);
    }
    
    public function getBackupContent(Backup $backup): string
    {
        return Storage::disk('public')->get($backup->path);
    }
    
    public function deleteBackup(Backup $backup): bool
    {
        if (Storage::disk('public')->exists($backup->path)) {
            Storage::disk('public')->delete($backup->path);
        }
        
        return $backup->delete();
    }
    
    public function cleanupOldBackups(int $days = 30): int
    {
        $cutoffDate = now()->subDays($days);
        $oldBackups = Backup::where('created_at', '<', $cutoffDate)->get();
        $deletedCount = 0;
        
        foreach ($oldBackups as $backup) {
            if ($this->deleteBackup($backup)) {
                $deletedCount++;
            }
        }
        
        return $deletedCount;
    }
    
    /**
     * Check if mysqldump is available on the system
     */
    public function isMysqldumpAvailable(): bool
    {
        try {
            $process = new Process(['mysqldump', '--version']);
            $process->run();
            return $process->isSuccessful();
        } catch (Exception $e) {
            return false;
        }
    }
}